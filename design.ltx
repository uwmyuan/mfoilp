\documentclass{article}

\title{Using Mercury to automate branch-price-and-cut}
\author{James Cussens}

\begin{document}

\maketitle


\section{Generating a cutting plane algorithm}
\label{sec:cuttingplanes}

A naive approach to generating cutting planes is to implement the
following sort of predicate:
\begin{verbatim}
:- pred cutting_plane(lpsol::in,lincons::out) is nondet.
cutting_plane(Sol,CP) :-
   delayed_constraint(CP),                   %1
   CP = lincons(finite(LB),LinExpr,posinf),  %2
   activity(Sol,LinExpr,Activity),           %3
   Activity < LB.                            %4
\end{verbatim}

Assuming, as we do throughout, Mercury's strict sequential semantics,
this generates the following algorithm:
\begin{enumerate}
\item A potential cutting plane is produced by generating a ground
  instance of some first-order constraint marked as \emph{delayed},
  which means that we have not already generated all its ground
  instances at the outset.
\item We then check that it is a constraint which effects only a lower
  bound. A clause is such a constraint. If we were to effect this
  approach we would need additional clauses to deal with different
  sorts of constraints.
\item We then compute the activity of this constraint with respect to
  the provided LP solution.
\item If the activity is too low, then the solution violates the
  constraint, and the constraint is a cutting plane.
\end{enumerate}

To generate a reasonable cutting plane algorithm we can do a
source-to-source transformation so that the cutting plane gets
gradually more instantiated. For example, suppose the following was
one of the clauses defining the predicate \verb+delayed_constraint+.:
\begin{verbatim}
delayed_constrain(Cons) :-
        protein(P1), location_id(L1), func_id(F1),
	Cons = lincons(finite(1.0),[1.0 * location(P1,L1), 1.0 *
	function(P1,F1), 1.0 * c1_broken(P1,L1,F1)],posinf).
\end{verbatim}
This is a (typed, first-order) clause arising from a MLN protein example.


We can fold this definition into a clause for generating a cutting
plane for some ground instance of this first-order clause:
\begin{verbatim}
cutting_plane(Sol,CP) :-
   protein(P1), location_id(L1),
   get_val(Sol,location(P1,L1),0,Val1),
   Val1 < 1,
   func_id(F1), 
   get_val(Sol,function(P1,F1),Val1,Val2),
   Val2 < 1,
   get_val(Sol,c1_broken(P1,L1,F1),Val2,Val3),
   Val3 < 1,
   CP = lincons(finite(1.0),[1.0 * location(P1,L1), 1.0 *
                  function(P1,F1), 1.0 * c1_broken(P1,L1,F1)],posinf).
\end{verbatim}

In this approach, we first find a \texttt{location} atom which has
value below 1 in the LP solution, and only then continue the search to
gradually instantiate the clause. For clauses the algorithm is simple:
generate ground instances of literals (left-to-right) and check that
the cumulative value is always below 1.


\end{document}
