/*
** vim: ts=4 sw=4 et
*/
#include <stdio.h>
#include <stdlib.h>

/*
** This header file is part of the stand-alone interface.
** It contains declarations for mercury_init() and mercury_terminate(),
** which are used to respectively start and shutdown the Mercury runtime.
*/
#include "mercury_lib_int.h"

/*
** mercury_lib.mh is generated by the compiler when we build libmercury_lib.
** It contains declarations for procedures exported by pragma foreign_export
** as well as other exported entities, like mutables.
**
*/
#include "mercury_lib.mh"

typedef MR_Word MR_AtomStore;
typedef MR_Word MR_IntList;
typedef MR_Word MR_FloatList;
typedef MR_Word MR_StringList;
typedef MR_Word MR_FloatListList;
typedef MR_Word MR_IntListList;

static void print_ints(MR_IntList);
static void print_floats(MR_FloatList);
static void print_vars(MR_IntList,MR_StringList,MR_FloatList,MR_FloatList,MR_IntList,MR_FloatList);
static void print_cons(MR_FloatList,MR_FloatListList,MR_IntListList,MR_FloatList);

int
main(int argc, char **argv)
{
    void *stack_bottom;

    MR_AtomStore atomstore;
    MR_IntList idents;
    MR_StringList names;
    MR_FloatList lbs;
    MR_FloatList ubs;
    MR_IntList vartypes;
    MR_FloatList objs;

    MR_FloatListList coeffss;
    MR_IntListList varss;

    /* Before calling any Mercury procedures we must first initialise
    ** the Mercury runtime, standard library and any other Mercury libraries
    ** that we will be using.  The function mercury_init() is used to do
    ** this.  In order it does the following:
    **
    ** (1) initialises the runtime
    ** (2) initialises the standard library
    ** (3) calls any predicates specified in `:- initialise' declarations
    **     and assigns any mutables their initial value   
    **
    ** We strongly recommend that calling this function is the first thing
    ** that your program does.
    **
    ** The third argument to mercury_init() is address of the base of the
    ** stack.  In grades that support conservative GC is used tell the
    ** collector where to begin tracing.
    */
    mercury_init(argc, argv, &stack_bottom);


    makevars(&atomstore,    /* don't need this to make variables
                               but needed for bookkeeping */
       &idents,             /* index for each variable to be created */
       &names,              /* name for each variable to be created */
       &lbs,                /* lower bound for each variable to be created */
       &ubs,                /* upper bound for each variable to be created */
       &vartypes,           /* variable type for each variable to be created */
       &objs);              /* objective coeff for each variable to be created */

    print_vars(idents,names,lbs,ubs,vartypes,objs);

    makelincons(atomstore,&lbs,&coeffss,&varss,&ubs);

    print_cons(lbs,coeffss,varss,ubs);

    /* print_ints(keys); */
    /* print_floats(objs); */

    usevars(atomstore);

    /*
    ** Once we have finished calling Mercury procedures then we shut
    ** down the Mercury runtime by calling the function
    ** mercury_terminate().  The value returned by this function 
    ** is Mercury's exit status (as set by io.set_exit_status/3.)
    **
    ** This function will also invoke any finalisers specified in
    ** `:- finalise' declarations in the set of Mercury libraries that
    ** we are using.
    */
    return mercury_terminate();
}

static void print_cons(
   MR_FloatList lbs,
   MR_FloatListList coeffss,
   MR_IntListList varss,
   MR_FloatList ubs
   ) 
{

   MR_FloatList coeffs;
   MR_IntList vars;

   while ( !MR_list_is_empty(lbs) )
   { 
      coeffs = MR_list_head(coeffss);
      vars = MR_list_head(varss);
      printf("%f =< ", MR_word_to_float(MR_list_head(lbs)));
      while ( !MR_list_is_empty(coeffs) )
      {
         printf("+ %f * %d ", MR_word_to_float(MR_list_head(coeffs)), MR_list_head(vars));
         coeffs = MR_list_tail(coeffs);
         vars = MR_list_tail(vars);
      }
      printf("=< %f\n", MR_word_to_float(MR_list_head(ubs)));
      lbs = MR_list_tail(lbs);
      coeffss = MR_list_tail(coeffss);
      varss = MR_list_tail(varss);
      ubs = MR_list_tail(ubs);
   }
}

static void print_vars(
   MR_IntList idents,
   MR_StringList names,
   MR_FloatList lbs,
   MR_FloatList ubs,
   MR_IntList vartypes,
   MR_FloatList objs
   ) 
{
   while ( !MR_list_is_empty(idents) ) 
   {
      printf("%d %s %f %f %d %f\n", 
         MR_list_head(idents),
         MR_list_head(names),
         MR_word_to_float(MR_list_head(lbs)),
         MR_word_to_float(MR_list_head(ubs)),
         MR_list_head(vartypes),
         MR_word_to_float(MR_list_head(objs))
         );
      idents = MR_list_tail(idents);
      names = MR_list_tail(names);
      lbs = MR_list_tail(lbs);
      ubs = MR_list_tail(ubs);
      vartypes = MR_list_tail(vartypes);
      objs = MR_list_tail(objs);
   }
}


static void print_ints(MR_IntList list) {
	if (MR_list_is_empty(list)) {
		printf("[]");
	} else {
		printf("[");
		printf("%d", MR_list_head(list));
		list = MR_list_tail(list);
		while (!MR_list_is_empty(list)) {
			printf(", %d",  MR_list_head(list));
			list = MR_list_tail(list);
		}
		printf("]");
	}
}

static void print_floats(MR_FloatList list) {
	if (MR_list_is_empty(list)) {
		printf("[]");
	} else {
		printf("[");
		printf("%f", MR_word_to_float(MR_list_head(list)));
		list = MR_list_tail(list);
		while (!MR_list_is_empty(list)) {
			printf(", %f",  MR_list_head(list));
			list = MR_list_tail(list);
		}
		printf("]");
	}
}
