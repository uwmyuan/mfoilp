\documentclass{article}

\title{mfoilp User/Developer manual}
\author{James Cussens}

\newcommand{\scip}{\textsf{SCIP}}
\newcommand{\mfoilp}{\textsf{mfoilp}}

\begin{document}

\maketitle

\section{Defining a problem instance}
\label{sec:prob}

The simplest way to create a first-order MIP problem instance is
to create a Mercury source file called \texttt{prob.m} with
the interface given in Fig~\ref{fig:interface}.


\begin{figure}
  \centering
\begin{verbatim}
:- module prob.
:- interface.

%----------------------------------------------------------------------%

:- import_module mfoilp.

:- type atom.

:- pred initial_variable(atom::out) is nondet.
:- pred delayed_variable(atom::out) is nondet.
:- pred initial_constraint(lincons::out) is nondet.
:- pred delayed_constraint(lincons::out) is nondet.

:- func objective(atom) = float.
:- func lb(atom) = float.
:- func ub(atom) = float.
:- func vartype(atom) = vartype.

%----------------------------------------------------------------------%
\end{verbatim}
  \caption{prob.m interface}
  \label{fig:interface}
\end{figure}

The \texttt{atom} type, the four predicates and the four functions
declared in this interface must, of course, be defined in the
implementation section of \texttt{prob.m} module. The user has
complete freedom concerning these definitions as long as they satisfy
the declarations in the interface.

For example, suppose we wanted to use \mfoilp{} to define and solve a
TSP instance for the 10 towns and their co-ordinates given by the
\texttt{data/3} predicate in Fig~\ref{fig:data}

\begin{figure}
  \centering
\begin{verbatim}
:- pred data(string,int,int).
:- mode data(out,out,out) is multi.
:- mode data(in,out,out) is semidet.

data("Sylt",       1, 1).
data("Flensburg",  3, 1).
data("Neumuenster", 2, 2).
data("Husum",      1, 3).
data("Schleswig",  3, 3).
data("Ausacker",   102, 4).
data("Rendsburg",  101, 4).
data("Luebeck",     4, 4).
data("Westerland", 0, 1).
data("Segeberg",   2, 3).
\end{verbatim}
  \caption{Data for a TSP instance}
  \label{fig:data}
\end{figure}

A standard MIP approach to TSP can be used where there is a binary
variable for each edge between any two towns. This leads to the
definition for \texttt{atom} in Fig~\ref{fig:atomtypedef}
\begin{figure}
  \centering
\begin{verbatim}
:- type atom ---> edge(string,string).
\end{verbatim}
  \caption{Example type definition for \texttt{atom}}
  \label{fig:atomtypedef}
\end{figure}


The variables which are to be initially included in the MIP instance
are generated by a suitable definition of \texttt{initial\_variable/1}
Using an simplifying predicate \texttt{town/1} to list the towns leads
to the definition of \texttt{initial\_variable/2} shown in
Fig~\ref{fig:initvars}.

\begin{figure}
  \centering
\begin{verbatim}
:- pred town(string::out) is multi.
town(X) :- data(X,_,_).

initial_variable(edge(Town1,Town2)) :-
	town(Town1),
	town(Town2),
	Town1 @< Town2.
\end{verbatim}
  \caption{Definition of \texttt{intial\_variables/1} predicate for a TSP
  instance}
  \label{fig:initvars}
\end{figure}

The objective coefficients, lower bounds, upper bounds and variable
types for these initial variables are easy to define for TSP, and are
the relevant function definitions are show in Fig~\ref{fig:funs}. (The
\texttt{dist/2} function, which is not shown, computes Euclidean
distance from the co-ordinates.)

\begin{figure}
  \centering
\begin{verbatim}
objective(edge(Town1,Town2)) = dist(Town1,Town2).
lb(_Atom) = 0.0.
ub(_Atom) = 1.0.
vartype(_Atom) = binary.
\end{verbatim}
  \caption{Objective coefficient, lower bound, upper bound and
    variable type definitions for TSP MIP variables}
  \label{fig:funs}
\end{figure}



The types \texttt{lincons} and \texttt{vartype} are defined in
\texttt{mfoilp} module and are given in Fig~\ref{fig:mfoilpypes}. The
\texttt{vartype} type simply enumerates the four MIP variables types
that \scip{} understands. The \texttt{lincons} type

\begin{figure}
  \centering
\begin{verbatim}
:- type lterm ---> (float * atom).
:- type lexp == list(lterm).
:- type lb ---> finite(float) ; neginf.
:- type ub ---> finite(float) ; posinf.
:- type lincons ---> lincons(lb,lexp,ub).
:- type vartype ---> binary ; integer ; implint ; continuous.
\end{verbatim}
  \caption{Type definition in the mfoilp module}
  \label{fig:mfoilptypes}
\end{figure}



First-order terms of type \texttt{atom}


\section{Mercury interface}
\label{sec:mercuryinterface}



The Mercury interface (currently implemented in \verb+mercury_lib.m+)
has to provide the following C functions:

\begin{description}
\item[MR\_consCheck]
  \verb+MR_consCheck(MR_AtomStore,MR_IntList,MR_FloatList)+.
  Checks that a solution satisfies the constraint. If called as 
\begin{verbatim}
MR_consCheck(atom_store,indices,values)
\end{verbatim}
then \verb+atom_store+
is the bimap between variable indices and atoms (treated as an
abstract data type by C), \texttt{indices} is a Mercury list of
integers which are indices of the non-zero variables in the solution,
\texttt{values} is the corresponding list of floats giving these
non-zero values. Returns true if the solution does satisfy the
constraint and false otherwise.
\item[MR\_consLock]   \verb+MR_consLock(MR_AtomStore,MR_Integer,&MR_Integer,&MR_Integer)+.
Computes the locks on a variable. If called as
\begin{verbatim}
MR_consLock(atom_store,(MR_integer) i,&up,&down)
\end{verbatim}
then \verb+atom_store+ is as above, \texttt{i} is the variable index
and \texttt{up} and \texttt{down} indicates whether the variable is up
and down locked, respectively.
\item[MR\_initial\_variables] Generates initial (i.e.\ not delayed)
  problem variables for SCIP. If called as
\begin{verbatim}
   MR_initial_variables(&atomstore,    /* don't need this to make variables
                               but needed for bookkeeping */
      &idents,             /* index for each variable to be created */
      &names,              /* name for each variable to be created */
      &lbs,                /* lower bound for each variable to be created */
      &ubs,                /* upper bound for each variable to be created */
      &vartypes,           /* variable type for each variable to be created */
      &objs);              /* objective coeff for each variable to be created */
\end{verbatim}
then arguments are as described in the comments above. This is the
function that create the \verb+atom_store+ bimap.
\item[MR\_initial\_constraints] Creates initial (i.e.\ not cutting
  plane) constraints. If called as:
\begin{verbatim}
   MR_initial_constraints(atomstore,&names,&lbs,&finlbs,
       &coeffss,&varss,&ubs,&finubs);
\end{verbatim}
then atomstore is as described earlier; \texttt{names} is an
\texttt{MR\_StringList} of constraint names, \texttt{lbs} is a
\texttt{MR\_FloatList} of constraint lower bounds (some of which may be
dummy values); \texttt{finlbs} is a \texttt{MR\_IntList} each of which
is either 0 or 1, a 0 indicates that the lower bound for the SCIP
constraint should be \texttt{-SCIPinfinity(scip)}; \texttt{coeffs} is
a \texttt{MR\_FloatListList} each element of which is a list
coefficients for a linear constraint; \texttt{varss} is an
\texttt{MR\_IntListList} each element of which is a list of variable
indices corresponding to \texttt{atomstore}; \texttt{ubs} and
\texttt{finubs} are the upper bounds which work exactly as the lower
bound arguments.
\end{description}

\section{FoLinear constraint handler}
\label{sec:folincons}

Currently CONSCHECK uses \verb+MR_consCheck+.


\end{document}
