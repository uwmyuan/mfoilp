\documentclass{article}

\title{mfoilp User/Developer manual}
\author{James Cussens}

\newcommand{\scip}{\textsf{SCIP}}
\newcommand{\mfoilp}{\textsf{mfoilp}}

\usepackage{url}

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

Throughout this manual we assume the reader is familiar with the
following:
\begin{enumerate}
\item The Mercury language ( \url{https://mercurylang.org/} )
\item Mixed-integer programming (MIP)
\end{enumerate}

\section{Defining a problem instance}
\label{sec:prob}

The simplest way to create a first-order MIP problem instance using
\mfoilp{} is to create a Mercury source file called \texttt{prob.m}
with the interface given in Fig~\ref{fig:interface}.
\begin{figure}
  \centering
\begin{verbatim}
:- module prob.
:- interface.

%----------------------------------------------------------------------%

:- import_module mfoilp.

:- type atom.

:- pred initial_variable(atom::out) is nondet.
:- pred delayed_variable(atom::out) is nondet.
:- pred initial_constraint(lincons::out) is nondet.
:- pred delayed_constraint(lincons::out) is nondet.

:- pred cuts(sol::in,list(lincons)::out) is semidet.

:- func objective(atom) = float.
:- func lb(atom) = float.
:- func ub(atom) = float.
:- func vartype(atom) = vartype.

%----------------------------------------------------------------------%
\end{verbatim}
  \caption{prob.m interface}
  \label{fig:interface}
\end{figure}
The \texttt{atom} type, the four predicates and the four functions
declared in this interface must, of course, be defined in the
implementation section of \texttt{prob.m} module. The user has
complete freedom concerning these definitions as long as they satisfy
the declarations in the interface. Any such definition is guaranteed
to define a MIP instance.

For example, suppose we wanted to use \mfoilp{} to define and solve a
TSP instance for the 10 towns and their co-ordinates given by the
\texttt{data/3} predicate in Fig~\ref{fig:data}. Representing problem
instance data by defining a predicate is an easy way to get the
information into the MIP. If the number of facts is large it is better
to implement the predicate using a Mercury \emph{fact table}. See the
Mercury documentation for details. One could alternatively write
Mercury code to read data from a file.

\begin{figure}
  \centering
\begin{verbatim}
:- pred data(string,int,int).
:- mode data(out,out,out) is multi.
:- mode data(in,out,out) is semidet.

data("Sylt",       1, 1).
data("Flensburg",  3, 1).
data("Neumuenster", 2, 2).
data("Husum",      1, 3).
data("Schleswig",  3, 3).
data("Ausacker",   102, 4).
data("Rendsburg",  101, 4).
data("Luebeck",     4, 4).
data("Westerland", 0, 1).
data("Segeberg",   2, 3).
\end{verbatim}
  \caption{Data for a TSP instance}
  \label{fig:data}
\end{figure}

A standard MIP approach to TSP can be used where there is a binary
variable for each edge between any two towns. This leads to the
definition for \texttt{atom} in Fig~\ref{fig:atomtypedef}.
\begin{figure}
  \centering
\begin{verbatim}
:- type atom ---> edge(string,string).
\end{verbatim}
  \caption{Example type definition for \texttt{atom}}
  \label{fig:atomtypedef}
\end{figure}
The variables which are to be initially included in the MIP instance
are generated by a suitable definition of \texttt{initial\_variable/1}.
Using an simplifying predicate \texttt{town/1} to list the towns leads
to the definition of \texttt{initial\_variable/1} shown in
Fig~\ref{fig:initvars}.

\begin{figure}
  \centering
\begin{verbatim}
:- pred town(string::out) is multi.
town(X) :- data(X,_,_).

initial_variable(edge(Town1,Town2)) :-
   town(Town1),
   town(Town2),
   Town1 @< Town2.
\end{verbatim}
  \caption{Definition of \texttt{intial\_variable/1} predicate for a TSP
  instance}
  \label{fig:initvars}
\end{figure}

The objective coefficients, lower bounds, upper bounds and variable
types for these initial MIP variables are easy to define for TSP, and
the relevant function definitions are show in Fig~\ref{fig:funs}. (The
\texttt{dist/2} function, which is not shown, computes Euclidean
distance from the co-ordinates.) The \texttt{vartype} type simply
enumerates the four MIP variables types that \scip{} understands. It
is defined in \texttt{mfoilp.m} as follows:
\begin{verbatim}
:- type vartype ---> binary ; integer ; implint ; continuous.
\end{verbatim}

The predicate \texttt{delayed\_variable/1} is used to define MIP
variables which are not initially present in the MIP, but which are
introduced `on demand' by a pricing algorithm. In the TSP example
there is no need for such variables so \texttt{delayed\_variable/1} is
defined as follows:
\begin{verbatim}
delayed_variable(_) :- fail.
\end{verbatim}
Omitting such a definition will cause Mercury to complain that the
definition of \texttt{delayed\_variable/1} is missing.

\begin{figure}
  \centering
\begin{verbatim}
objective(edge(Town1,Town2)) = dist(Town1,Town2).
lb(_Atom) = 0.0.
ub(_Atom) = 1.0.
vartype(_Atom) = binary.
\end{verbatim}
  \caption{Objective coefficient, lower bound, upper bound and
    variable type definitions for TSP MIP variables}
  \label{fig:funs}
\end{figure}

The \texttt{lincons} type is defined in the \texttt{mfoilp} module and
is shown in Fig~\ref{fig:mfoilptypes}.
\begin{figure}
  \centering
\begin{verbatim}
:- type lterm ---> (float * atom).
:- type lexp == list(lterm).
:- type lb ---> finite(float) ; neginf.
:- type ub ---> finite(float) ; posinf.
:- type lincons ---> lincons(lb,lexp,ub).
\end{verbatim}
  \caption{Definition of the \texttt{lincons} type in the mfoilp module}
  \label{fig:mfoilptypes}
\end{figure}
It is the type for linear constraints each of which is specified by a
linear expression and a lower and upper bound. Lower and upper bounds
can be either finite or negative/positive infinite. The linear
expression is represented by a list (representing a sum) of linear
terms. A linear term is just a MIP variable (i.e.\ an \texttt{atom})
together with its coefficient. 

The \texttt{intial\_constraint/1} predicate specifies which linear
constraints are initially present in the MIP instance.  In the TSP
example, there is an initial constraint for each town requiring that
there are exactly two edges incident to that town. See
Fig~\ref{fig:initcons}. In this definition \texttt{Edge} is a
higher-order term which is an argument for \texttt{solutions/2},
Mercury's equivalent of Prolog's \texttt{findall}. 
\begin{figure}
  \centering
\begin{verbatim}
initial_constraint(lincons(finite(2.0),LinExpr,finite(2.0))) :-
   town(Town),
   Edges = (pred(1.0 * Edge::out) is nondet :- initial_variable(Edge),
      (Edge=edge(_,Town);Edge=edge(Town,_))),
   solutions(Edges,LinExpr).
\end{verbatim}
  \caption{Definition of \texttt{intial\_constraint/1} predicate for a TSP
  instance}
  \label{fig:initcons}
\end{figure}

Although for the small TSP instance it would be possible to add all
subtour elimination constraints initially to the MIP instance, this is
impracticable for larger TSP instances so the subtour elimination
constraints are defined as delayed constraints using the
\texttt{delayed\_constraint/1} predicate, as show in
Fig~\ref{fig:delayedcons}. A delayed constraint can only be added if
the current LP solution violates it. Note that we do not wait until
the MIP is solved before looking for violated delayed constraints, they are
added as soon as a \emph{linear relaxation} of the MIP is solved.

\begin{figure}
  \centering
\begin{verbatim}
delayed_constraint(lincons(neginf,LinExpr,finite(float(Size-1)))) :-
   solutions(town,AllTowns),
   N = length(AllTowns),
   subset(AllTowns,N,2,N-2,Towns,Size), 
   Edges = (pred(1.0 * Edge::out) is nondet :- initial_variable(Edge),
      Edge = edge(Town1,Town2),
      member(Town1,Towns), member(Town2,Towns)),
   solutions(Edges,LinExpr).
\end{verbatim}
  \caption{Definition of \texttt{delayed\_constraint/1} predicate for a TSP
  instance}
  \label{fig:delayedcons}
\end{figure}

Finally, consider the \texttt{cuts/2} predicate declared in the
interface of \texttt{prob.m}. This predicate can be used to define a
specialised cutting plane algorithm for the efficient generation of
delayed constraints. Since the TSP instance is small there is no need
to come up with a good cutting plane algorithm, but the predicate
still needs to be defined. Defining \texttt{cuts/2} to always fail:
\begin{verbatim}
cuts(_,_) :- fail.
\end{verbatim}
is the correct way to indicate to \mfoilp{} that no cutting plane
algorithm has been written for this problem.

\section{Solving with \mfoilp}
\label{sec:solving}

To solve with \mfoilp{} write \verb+make solution+ at the command
line. This will do any necessary compilation and linking to create
a problem specific executable with a name such as
\verb+mfoilp.linux.x86_64.gnu.opt.spx+ and add a symbolic link called just
\texttt{mfoilp} to that executable. The executable will then be run to
solve the MIP. The (edited) output produced when solving the TSP
instance is shown in Fig~\ref{fig:running}.

\begin{figure}
  \centering
\begin{verbatim}
...
presolved problem has 45 variables (45 bin, 0 int, 0 impl, 0 cont) and 11 constraints
      1 constraints of type <folinear>
     10 constraints of type <linear>
Presolving Time: 0.02
 time |frac |vars |cons |cols |rows |cuts |  dualbound   | primalbound  |  gap   
  0.6s|   0 |  45 |  11 |  45 |  10 |   0 | 2.060645e+02 |      --      |    Inf 
  0.6s|   0 |  45 |  11 |  45 |  11 |   1 | 2.065242e+02 |      --      |    Inf 
* 0.6s|   - |  45 |  11 |  45 |  11 |   1 | 2.065242e+02 | 2.065242e+02 |   0.00%

SCIP Status        : problem is solved [optimal solution found]
...
objective value:                     206.524152779934
edge("Ausacker", "Flensburg")                       1 	(obj:99.0454441153151)
edge("Ausacker", "Rendsburg")                       1 	(obj:1)
edge("Flensburg", "Neumuenster")                    1 	(obj:1.4142135623731)
edge("Husum", "Segeberg")                           1 	(obj:1)
edge("Husum", "Westerland")                         1 	(obj:2.23606797749979)
edge("Luebeck", "Rendsburg")                        1 	(obj:97)
edge("Luebeck", "Schleswig")                        1 	(obj:1.4142135623731)
edge("Neumuenster", "Sylt")                         1 	(obj:1.4142135623731)
edge("Schleswig", "Segeberg")                       1 	(obj:1)
edge("Sylt", "Westerland")                          1 	(obj:1)
\end{verbatim}
  \caption{Solving a TSP instance with \mfoilp}
  \label{fig:running}
\end{figure}
In Fig~\ref{fig:running} we can see that the MIP starts with the $10
\times 9 /2 = 45$ edge variables and the 10 initial constraints which get
translated into 10 SCIP linear constraints. The constraint
\texttt{folinear} is there to ensure that any solution also satisfies
all the delayed constraints. In this example, it is enough to add only
one of these delayed constraints (out of a possible $2^{10} - 1 - 10 -
45 - 1 - 10 = 957$) to solve the problem. See the \texttt{cuts} column
in Fig~\ref{fig:running}. In this example both linear relaxation
solutions have, by chance, no non-integer variables (see the
\texttt{frac} column); typically LP solutions do have fractional
values. Note too that although only one delayed constraint is
\emph{added} as a cutting plane, it is necessary for \mfoilp{} to
\emph{check} that all delayed constraints are satisfied before it can
be sure it has found a feasible solution.

\section{Being more efficient}
\label{sec:efficiency}

The simplest way to use \mfoilp{} is to define only initial variables
and constraints. These are used to create a MIP instance which SCIP
solves in the normal way. If a problem requires (or is more
efficiently solved with) many variables and/or constraints it will be
necessary to declare these as delayed variables and constraints.

However, the default \mfoilp{} approach to generating delayed
variables and constraints is very inefficient. For delayed
constraints, each delayed constraint is generated in turn and only
then tested to see if it is a cutting plane. The same approach is
taken with delayed variables; they too are enumerated until one with
negative reduced cost is generated (or we run out of delayed
variables).

To avoid this pure generate-and-test approach, the user has the option
of supplying a cutting plane algorithm and/or a pricer by writing one
in the file \texttt{prob.m} which defines the instance. To write a
cutting plane algorithm one defines the \texttt{cuts/2} predicate so
that it does not fail (as it did in the TSP example), but instead
generates zero or more delayed constraints which are violated by the
current LP solution. \emph{If this is done, the
  \texttt{delayed\_constraint} predicate is no longer used to generate
  delayed constraints}, so there is no point in defining it to be
anything other than:
\begin{verbatim}
delayed_constraint(_) :- fail.
\end{verbatim}



\section{Mercury interface}
\label{sec:mercuryinterface}



The Mercury interface (currently implemented in \verb+mercury_lib.m+)
has to provide the following C functions:

\begin{description}
\item[MR\_consCheck]
  \verb+MR_consCheck(MR_AtomStore,MR_IntList,MR_FloatList)+.
  Checks that a solution satisfies the constraint. If called as 
\begin{verbatim}
MR_consCheck(atom_store,indices,values)
\end{verbatim}
then \verb+atom_store+
is the bimap between variable indices and atoms (treated as an
abstract data type by C), \texttt{indices} is a Mercury list of
integers which are indices of the non-zero variables in the solution,
\texttt{values} is the corresponding list of floats giving these
non-zero values. Returns true if the solution does satisfy the
constraint and false otherwise.
\item[MR\_consLock]   \verb+MR_consLock(MR_AtomStore,MR_Integer,&MR_Integer,&MR_Integer)+.
Computes the locks on a variable. If called as
\begin{verbatim}
MR_consLock(atom_store,(MR_integer) i,&up,&down)
\end{verbatim}
then \verb+atom_store+ is as above, \texttt{i} is the variable index
and \texttt{up} and \texttt{down} indicates whether the variable is up
and down locked, respectively.
\item[MR\_initial\_variables] Generates initial (i.e.\ not delayed)
  problem variables for SCIP. If called as
\begin{verbatim}
   MR_initial_variables(&atomstore,    /* don't need this to make variables
                               but needed for bookkeeping */
      &idents,             /* index for each variable to be created */
      &names,              /* name for each variable to be created */
      &lbs,                /* lower bound for each variable to be created */
      &ubs,                /* upper bound for each variable to be created */
      &vartypes,           /* variable type for each variable to be created */
      &objs);              /* objective coeff for each variable to be created */
\end{verbatim}
then arguments are as described in the comments above. This is the
function that create the \verb+atom_store+ bimap.
\item[MR\_initial\_constraints] Creates initial (i.e.\ not cutting
  plane) constraints. If called as:
\begin{verbatim}
   MR_initial_constraints(atomstore,&names,&lbs,&finlbs,
       &coeffss,&varss,&ubs,&finubs);
\end{verbatim}
then atomstore is as described earlier; \texttt{names} is an
\texttt{MR\_StringList} of constraint names, \texttt{lbs} is a
\texttt{MR\_FloatList} of constraint lower bounds (some of which may be
dummy values); \texttt{finlbs} is a \texttt{MR\_IntList} each of which
is either 0 or 1, a 0 indicates that the lower bound for the SCIP
constraint should be \texttt{-SCIPinfinity(scip)}; \texttt{coeffs} is
a \texttt{MR\_FloatListList} each element of which is a list
coefficients for a linear constraint; \texttt{varss} is an
\texttt{MR\_IntListList} each element of which is a list of variable
indices corresponding to \texttt{atomstore}; \texttt{ubs} and
\texttt{finubs} are the upper bounds which work exactly as the lower
bound arguments.
\end{description}

\section{FoLinear constraint handler}
\label{sec:folincons}

Currently CONSCHECK uses \verb+MR_consCheck+.


\end{document}
