#include <string.h>
#include <stdio.h>
#include <stdlib.h>


#include <scip/scip.h>
#include <scip/scipdefplugins.h>


/*
** This header file is part of the stand-alone interface.
** It contains declarations for mercury_init() and mercury_terminate(),
** which are used to respectively start and shutdown the Mercury runtime.
*/
#include "mercury_lib_int.h"

/*
** mercury_lib.mh is generated by the compiler when we build libmercury_lib.
** It contains declarations for procedures exported by pragma foreign_export
** as well as other exported entities, like mutables.
**
*/
#include "mercury_lib.mh"

typedef MR_Word MR_AtomStore;
typedef MR_Word MR_IntList;
typedef MR_Word MR_FloatList;
typedef MR_Word MR_StringList;
typedef MR_Word MR_FloatListList;
typedef MR_Word MR_IntListList;


/** main function (just for testing at present ) */
int main(
   int                        argc,          /**< number of arguments from the shell */
   char**                     argv           /**< array of shell arguments */
   )
{
   void *stack_bottom;

   MR_AtomStore atomstore;
   MR_IntList idents;
   MR_StringList names;
   MR_FloatList lbs;
   MR_FloatList ubs;
   MR_IntList vartypes;
   MR_FloatList objs;
   
   MR_FloatListList coeffss;
   MR_IntListList varss;

   MR_FloatList coeffs;
   MR_IntList vars;

   SCIP* scip = NULL;
   SCIP_CONS* cons;
   SCIP_VAR* var;

   SCIP_VAR* mercury_vars[2000];

   int ident;
   MR_String name;
   SCIP_Real lb;
   SCIP_Real ub;   
   SCIP_Real obj;
   int vartype;

   SCIP_Real coeff;   

   mercury_init(argc, argv, &stack_bottom);
   
   makevars(&atomstore,    /* don't need this to make variables
                               but needed for bookkeeping */
      &idents,             /* index for each variable to be created */
      &names,              /* name for each variable to be created */
      &lbs,                /* lower bound for each variable to be created */
      &ubs,                /* upper bound for each variable to be created */
      &vartypes,           /* variable type for each variable to be created */
      &objs);              /* objective coeff for each variable to be created */

   /* initialize SCIP */
   SCIP_CALL( SCIPcreate(&scip) );

   /* include default SCIP plugins */
   SCIP_CALL( SCIPincludeDefaultPlugins(scip) );

   SCIP_CALL( SCIPcreateProbBasic(scip, "folilp") );

   SCIP_CALL( SCIPsetObjsense(scip, SCIP_OBJSENSE_MAXIMIZE) );

   /* add Mercury variables */
   while ( !MR_list_is_empty(idents) ) 
   {
      ident =   MR_list_head(idents);
      name =    (MR_String) MR_list_head(names);
      lb =      MR_word_to_float(MR_list_head(lbs));
      ub =      MR_word_to_float(MR_list_head(ubs));
      obj =     MR_word_to_float(MR_list_head(objs));
      vartype = MR_list_head(vartypes);

      SCIP_CALL( SCIPcreateVarBasic(scip, &var, name, lb, ub, obj, vartype) );
      SCIP_CALL( SCIPaddVar(scip, var) );
      mercury_vars[ident] = var;

      idents = MR_list_tail(idents);
      names = MR_list_tail(names);
      lbs = MR_list_tail(lbs);
      ubs = MR_list_tail(ubs);
      objs = MR_list_tail(objs);
      vartypes = MR_list_tail(vartypes);
   }

   
   makelincons(atomstore,&lbs,&coeffss,&varss,&ubs);

   while ( !MR_list_is_empty(lbs) )
   { 
      coeffs = MR_list_head(coeffss);
      vars = MR_list_head(varss);
      lb =      MR_word_to_float(MR_list_head(lbs));
      ub =      MR_word_to_float(MR_list_head(ubs));

      /* add a constraint */
      SCIP_CALL( SCIPcreateConsBasicLinear(scip, &cons, "todo", 0, NULL, NULL, lb, ub) );
      while ( !MR_list_is_empty(coeffs) )
      {
         coeff = MR_word_to_float(MR_list_head(coeffs));
         var = mercury_vars[MR_list_head(vars)];
         SCIP_CALL( SCIPaddCoefLinear(scip, cons, var, coeff) );
         coeffs = MR_list_tail(coeffs);
         vars = MR_list_tail(vars);

      }
      SCIP_CALL( SCIPaddCons(scip, cons) );
      SCIP_CALL(  SCIPprintCons(scip, cons, NULL)  );
      SCIP_CALL( SCIPreleaseCons(scip, &cons) );

      coeffss = MR_list_tail(coeffss);
      varss = MR_list_tail(varss);
      lbs = MR_list_tail(lbs);
      ubs = MR_list_tail(ubs);
   }

   /* solve the model */
   SCIP_CALL( SCIPsolve(scip) );

   SCIP_CALL( SCIPprintBestSol(scip, NULL, FALSE) );

   /* SCIP_CALL( SCIPprintStatistics(scip, NULL) ); */

   SCIP_CALL( SCIPfree(&scip) );

   BMScheckEmptyMemory();

   return mercury_terminate();

   return 0;
}   
