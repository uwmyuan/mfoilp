#include <string.h>
#include <stdio.h>
#include <stdlib.h>


#include <scip/scip.h>
#include <scip/scipdefplugins.h>


/*
** This header file is part of the stand-alone interface.
** It contains declarations for mercury_init() and mercury_terminate(),
** which are used to respectively start and shutdown the Mercury runtime.
*/
#include "mercury_lib_int.h"

/*
** mercury_lib.mh is generated by the compiler when we build libmercury_lib.
** It contains declarations for procedures exported by pragma foreign_export
** as well as other exported entities, like mutables.
**
*/
#include "mercury_lib.mh"

typedef MR_Word MR_AtomStore;
typedef MR_Word MR_IntList;
typedef MR_Word MR_FloatList;
typedef MR_Word MR_StringList;
typedef MR_Word MR_FloatListList;
typedef MR_Word MR_IntListList;


/** main function (just for testing at present ) */
static
int makesolveprob(
   char*                     filename
   )
{
   SCIP* scip = NULL;
   SCIP_CONS* cons;
   SCIP_VAR* var;

   
   /* initialize SCIP */
   SCIP_CALL( SCIPcreate(&scip) );

   /* include default SCIP plugins */
   SCIP_CALL( SCIPincludeDefaultPlugins(scip) );

   SCIP_CALL( SCIPcreateProbBasic(scip, "dummy") );


   SCIP_CALL( SCIPsetObjsense(scip, SCIP_OBJSENSE_MAXIMIZE) );

   /* add a variable */
   SCIP_CALL( SCIPcreateVarBasic(scip, &var, "todo", 0.0, 10.0, 20, SCIP_VARTYPE_INTEGER) );
   SCIP_CALL( SCIPaddVar(scip, var) );
   
   /* add a constraint */
   SCIP_CALL( SCIPcreateConsBasicLinear(scip, &cons, "todo", 0, NULL, NULL, 0, 5) );
   SCIP_CALL( SCIPaddCoefLinear(scip, cons, var, 1) );
   SCIP_CALL( SCIPaddCons(scip, cons) );
   SCIP_CALL( SCIPreleaseCons(scip, &cons) );

   /* solve the model */
   SCIP_CALL( SCIPsolve(scip) );

   SCIP_CALL( SCIPprintBestSol(scip, NULL, FALSE) );

   /* SCIP_CALL( SCIPprintStatistics(scip, NULL) ); */

   SCIP_CALL( SCIPfree(&scip) );

   return 0;
}

/** main function (just for testing at present ) */
int main(
   int                        argc,          /**< number of arguments from the shell */
   char**                     argv           /**< array of shell arguments */
   )
{
   int result;

   void *stack_bottom;

   MR_AtomStore atomstore;
   MR_IntList idents;
   MR_StringList names;
   MR_FloatList lbs;
   MR_FloatList ubs;
   MR_IntList vartypes;
   MR_FloatList objs;
   
   MR_FloatListList coeffss;
   MR_IntListList varss;


   mercury_init(argc, argv, &stack_bottom);
   
   makevars(&atomstore,    /* don't need this to make variables
                               but needed for bookkeeping */
      &idents,             /* index for each variable to be created */
      &names,              /* name for each variable to be created */
      &lbs,                /* lower bound for each variable to be created */
      &ubs,                /* upper bound for each variable to be created */
      &vartypes,           /* variable type for each variable to be created */
      &objs);              /* objective coeff for each variable to be created */
   

   if( argc != 2 )
   {
      printf("Expected exactly one argument. Aborting\n");
      return 1;
   }

   result = makesolveprob(argv[1]);
   
   BMScheckEmptyMemory();

    return mercury_terminate();


   return result;
}   
