We want an initial executable that:

creates all SCIP variables via a call to Mercury
creates all SCIP constraints via a call to Mercury

start by creating executable where variables and constraints are
generated and then just printed out.

Fri Jun 12 16:23:09 CEST 2015

understanding SCIP makefile

first (non-phony) target is $(MAINSHORTLINK), this depends on
$(MAINFILE) and is created via symbolic linking

Main dependency for $(MAINFILE) is MAINOBJFILES which is just MAINOBJ
in the appropriate directory.

In Mercury makefile, final step is to link c_main.o and
mercury_lib_int.o with MERCURY_LIB_LDFLAGS

mercury_lib.init dependency is just so that stuff is recompiled if a
.m file changes

bascially we make mercury_lib_init.o by compiling mercury_lib
with mmc appropriately, and make c_main.o using gcc

presumably should override $(OBJDIR)/%.o:	$(SRCDIR)/%.c
so that object files are created in the right way.

Sun Jun 14 20:44:56 CEST 2015

SCIPMakefile.orig compiles SCIP executable
MercuryMakefile.orig complies Mercury-linked executable

Mon Jun 15 16:55:09 CEST 2015

Have interface working where all variables and constraints are created
at the beginning.

Plan: get cutting plane approach working first. This requires writing
a constraint handler. Will assume that only implicit linear
constraints will be handled by cons_folinear.c (Initial constraints
are dealt with already). What to do about variables?

separator should just take current solution and atom_store and ask
mercury for a violating constraint. perhaps Mercury should provide
the lock information.

Thu Jun 18 08:40:34 BST 2015

Division of labour:

cons_folinear:

consdata is
(1) the current atom_store
(2) an array of variables indicating variables "in the constraint",
indexes of variables correpsond to those in atom_store, each variable
knows its index, since this will be stored in its VARDATA.


CONSCHECK:
Given a solution, does it satisfy the constraint?
calls a Mercury function with these inputs:
(1) the atom_store (from consdata)
(2) a list of ints (for each non-zero variable in solution)
(3) a list of floats (the non-zero values of the variables in that
solution)
Mercury function returns true or false.

CONSENFOLP:
for the time being just call CONSCHECK

CONSENFOPS:
for the time being just call CONSCHECK

CONSLOCK:
for each variable "in the constraint" we call a Mercury function with
these inputs:
(1) the atom_store
(2) the variable's index
Mercury returns an encoding of up, down or both

CONSSEPALP:
Given a solution (represented as for CONSCHECK), we return cuts
using the same approach as for the current makelincons

Mon Jun 29 20:32:09 CEST 2015

When a variable is created we need to declare how the constraint locks
it. How to do this without grounding out all variables? Could demand
that user declares this information.
Given a variable (ground atom), need to find ground instances of
linear constraints containing it.
Need to get the list of variables first, (attempt to ) unify with
relevant variable, and then check any further conditions.

instead of ic(lincons(0.2,[1.0 * f(X,Y)],3.0) :- conds(X,Y).
and then see if f(a,b) in the list

want ic(lincons(0.2,[1.0 * f(X,Y)],3.0) :- f(X,Y) = f(a,b), conds(X,Y).

Fri Jul  3 08:52:12 CEST 2015

Attempting to use simple Mercury approach to solving MLNs.
Perhaps protein example is not good since do not appear to have data
for it.

Will use entity resolution as a target. Already have Python to convert
MLNs (either in rockit or alchemy format) into ZIMPL.

ZIMPL+SCIP cannot handle large MLNs. Here is an approach that might
work
put all "normal atoms" as initial variables
all evidence as initial constraints
clauses are delayed so will need to generate them as cutting planes

for delayed constraint looks like they have to be written as:

delayed_constraint(Sol::in,Cons::out) :-
	protein(P1), location_id(L1),
	get_val(Sol,location(P1,L1),Val),
	Val < 1,
	func_id(F1), get_val(Sol,function(P1,F1),Val2),
	V = Val + Val2, V < 1,
	get_val(Sol,c1_broken(P1,L1,F1),V3),
	V + V3 < 1,
	Cons = lincons(finite(1.0),[1.0 * location(P1,L1), 1.0 *
	function(P1,F1), 1.0 * c1_broken(P1,L1,F1)],posinf).

ie given a solution, we generate a constraint which violates it. the
constraint definition is implicit in the code for generating it.


perhaps we need automatic rewriting so that from

cons(Cons), break(Sol,Cons)

we get breaks(Sol,Cons) with lots of 'early' checking.

Approach for MLNs:

1. Take input MLN (in whatever format) and generate prob.m input. This
will involved writing complex code for delayed_constraint/2 (and also
for variable pricing).
2. Branch-price-and-cut solving. Mercury supplies some initial
variables and constraints. Also provides a pricer and cutting
planes. The latter via the fo_linear constraint handler.

% for clauses
delayed_constraint(Sol::in,Cons::out) :-

delayed_constraint(Sol,ValIn,ValOut,L

Mon Jul  6 15:17:18 BST 2015

to do.

1) How to get from declaration of constraints to Mercury-implemented
cutting plane algorithm.
2) Are there any useful examples where just statically creating
constraints and variables is useful?
3) Writing the revised position paper.


cutting_plane(CP,!SolVal) :-
  protein(P1), location(L1),
  lit(location(P1,L1),!SolVal),
  func_id(F1),
  lit(func_id(P1,F1),!SolVal),
  lit(c1_broken(P1,L1,F1),!SolVal),
  is_clause([location(P1,L1),func_id(P1,F1),c1_broken(P1,L1,F1)],CP).

lit(Atom,Sol-VIn,Sol-VOut) :-
  get_val(Sol,Atom,V),
  VOut = VIn + V,
  VOut < 1.


OK, so can make it look more pretty.

Tue Jul 14 08:40:11 CEST 2015

for locking could (inefficiently) do:
locks(AtomStore,Index,Up,Down) :-
	bimap.lookup(AtomStore,Index,Atom),
	Call = (
		 pred(Out::out) is nondet :- prob.delayed_constraint(Cons),
		 Cons = lincons(Lb,LExp,Ub),
		 list.member(F*Atom,LExp),
		 Out = lockinfo(Lb,F,Ub)
	       ),
	do_while(Call,filter,neither,Locks),
	locknum(Locks,Up,Down).

which allows a simple definition of
delayed_constraint(Cons). algorithm then is:
generate a ground instance of a first-order constraint, see whether
the atom is mentioned in that ground instance. If so, add any locks.
decided to initially do this

Tue Aug 18 11:12:50 BST 2015

The main idea behind this approach

:- type state ---> state(sol,float,list(atom),list(atom)).

clause -->
	{person(X)},
	neglit(smokes(X)),
	poslit(cancer(X)),
	poslit(cb(1,X)).

poslit(Atom,
       state(Sol,ValIn,NegIn,PosIn),
       state(Sol,ValOut,NegIn,[Atom|PosIn])) :-
       ValOut = ValIn+solval(Sol,Atom),
       ValOut < 1.0.
...

is that a constraint is created from a solution. Here the state type
is specifically designed for clauses.

* Need a better name for "state" type
* Do we rewrite all constraints like clauses?

Decided to focus on getting MLN solving working, so only "clever" cuts
for first-order clauses.

How mfoilp solves the MAP problem for MLNs

1. The MLN is supplied as a problem instance. Clauses are defined
thus:

clause -->
	neglit(cancer(bob)).


clause -->
	{person(X)},
	neglit(smokes(X)),
	poslit(cancer(X)),
	poslit(cb1(1,X)).

2. All MIP variables ( = 'atoms' ) are created at the
beginning. All variables are sent to the FOLinear constructor and so
are 'in' the single FOLinear constraint. They are all locked there.

3. Solutions are sent to Mercury from cons_folinear for checking and
cutting plane generation.


At present MIP variables are locked by generating all ground instances and
then seeing if the MIP variable in question is 'in' that ground
instance.


Wed Aug 19 10:35:34 BST 2015

For generating cuts we should generate negative literals from the
solution:


:- pred neglit(atom::out,clause_info::in,clause_info::out) is semidet.
neglit(Atom,
       clause_cut(Sol,ValIn,NegIn,PosIn),
       clause_cut(Sol,ValOut,[Atom|NegIn],PosIn)) :-
	map.member(Sol,Atom,Val),
	ValOut = ValIn+1.0-Val,
	ValOut < 1.0.

but to build a clause should do this:

neglit(Atom,
       clause_build(NegIn,PosIn),
       clause_build([Atom|NegIn],PosIn)) :- initial_variable(Atom).

Wed Aug 19 15:06:53 BST 2015

Now moved to declaring variable lock information in the problem
instance. Like this:

is_poslit(smokes(bob)).
is_poslit(cancer(_)).
is_poslit(cb1(1,_)).
is_poslit(cb2(2,_,_)).
is_poslit(smokes(_)).

is_neglit(cancer(bob)).
is_neglit(smokes(_)).
is_neglit(friends(X,Y)) :- not X = Y.

Current MLN solving approach
All variables declared using initial_variable in problem
instance. cuts/2, initial_constraint/1 and delayed_constraint/1 all
declared as fail. But clause/3 predicate defined which declares the
clauses. SCIP creates the variables and keeps the atomstore pointer
(which has been created by Mercury). A single folinear constraint is
created with all variables included. This computes locks on all
variables. And calls MR_cuts to get cuts for linear
relaxations. MR_cuts is just the exported name for cuts/10 which finds
all cuts for current solution. Same predicate ( clausal_cut/2) is used
for checking.

MR_cuts needs to return *constraint indices* when returning cuts, so
that the rows can be stored with the correct index in the probdata cons_store.

Thu Aug 20 14:34:31 BST 2015

Due to definition of poslit and solval we can create constraints
containing MIP variables == atoms, for which there is no corresponding variable.

Just need to add new variables into constraints and cutting planes
